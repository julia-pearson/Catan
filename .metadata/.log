!SESSION 2015-02-09 21:44:26.861 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-09 21:45:01.583
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-09 21:46:28.654 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-09 21:46:44.862
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-12 07:50:22.211 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-12 07:50:29.621
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-12 15:05:36.025 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-12 15:05:45.699
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-12 21:12:25.581 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-12 21:12:36.745
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-13 12:21:06.367 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-13 12:21:15.373
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.ui 4 0 2015-02-13 13:31:05.299
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
	at org.eclipse.swt.widgets.Widget.filters(Widget.java:794)
	at org.eclipse.swt.widgets.Control.scrollWheel(Control.java:2455)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5539)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:220)
	at org.eclipse.swt.widgets.Widget.scrollWheel(Widget.java:1438)
	at org.eclipse.swt.widgets.Control.scrollWheel(Control.java:2464)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5539)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:220)
	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2095)
	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2253)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5535)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:4989)
	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5138)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
!SESSION 2015-02-19 10:55:00.193 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-19 10:55:08.316
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-22 02:45:51.207 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-22 02:45:58.344
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-24 18:57:44.687 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-24 18:57:51.534
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-24 20:00:49.222 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-24 20:00:55.907
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-24 20:39:05.113 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-24 20:39:15.196
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-25 22:17:08.915 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.resources 2 10035 2015-02-25 22:17:21.800
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.core.net 1 0 2015-02-25 22:17:24.523
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-26 13:29:10.032 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-26 13:29:22.406
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-26 16:24:08.811 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-26 16:24:16.985
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-02-26 16:35:34.412 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-02-26 16:35:40.386
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-01 21:27:46.824 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-01 21:27:55.091
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
<<<<<<< HEAD
!SESSION 2015-03-01 22:40:13.303 -----------------------------------------------
=======
!SESSION 2015-03-01 23:17:28.540 -----------------------------------------------
>>>>>>> pr/18
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

<<<<<<< HEAD
!ENTRY org.eclipse.core.resources 2 10035 2015-03-01 22:40:17.345
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.core.net 1 0 2015-03-01 22:40:20.578
=======
!ENTRY org.eclipse.core.net 1 0 2015-03-01 23:17:35.064
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-01 23:29:19.970 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-01 23:29:25.932
>>>>>>> pr/18
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-07 09:00:00.559 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-07 09:00:09.585
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.ui 4 0 2015-03-07 09:33:55.204
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
	at org.eclipse.swt.widgets.Widget.filters(Widget.java:794)
	at org.eclipse.swt.widgets.Control.scrollWheel(Control.java:2455)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5539)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:220)
	at org.eclipse.swt.widgets.Widget.scrollWheel(Widget.java:1438)
	at org.eclipse.swt.widgets.Control.scrollWheel(Control.java:2464)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5539)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:220)
	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2095)
	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2253)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5535)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:4989)
	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5138)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
!SESSION 2015-03-07 12:44:26.642 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-07 12:44:33.394
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-08 18:13:02.435 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-08 18:13:09.338
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-09 16:58:14.947 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-09 16:58:22.058
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-10 11:20:35.568 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-10 11:20:42.953
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-10 13:05:29.491 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-10 13:05:36.136
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-10 13:17:46.026 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-10 13:17:57.597
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.jdt.core 4 4 2015-03-10 13:25:24.706
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Graphics;
import java.awt.Polygon; 
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import javax.swing.JFrame;
import javax.swing.JPanel;
import java.awt.geom.Arc2D;
import java.awt.font.TextAttribute;
import java.awt.Font;
import java.awt.RenderingHints;

public class Hexanew extends JFrame{
  Graphics g;
  Graphics2D g2;
  FrontEndInterface interaction;

  //CONSTANT__________

  //size of each small polygol, one side=2a
  int a = 40;
  //board coordinates, at the lowest left corner of the lowest left tile, chosen for asthetics
  int x = 250;
  int y = 720;
  //width=1/2 of full width of hexagon, only initiallizing to change from double
  double width=2*a/1.155;
  int w= (int) width;
  //ratio of little hexagon side to big hexagon side, only initiallizing to change from double
  double aBorder = 6*a/1.155;
  int a1 = (int) aBorder;

  //Making colors
  Color water = new Color (54, 183, 235);
  Color brick = new Color (152, 0, 0);
  Color wood = new Color (0, 102, 0);
  Color stone = new Color (115, 115, 115);
  Color wheat = new Color (247, 244, 57);
  Color sheep = new Color (102, 255, 102);
  Color dessert = new Color (235, 177, 54);
  Color circles = new Color (255,248,220);
  Color darkBlue = new Color (0,0,204);
  Color darkYellow = new Color (219,223,93);
  Color gray = new Color (160,160,160);
  Color white = new Color (224,224,224);
  Color orange = new Color (255,128,0);
  Color blue = new Color (0,0,224);
  Color red = new Color (218,46,46);
  Color robberGray = new Color (144,144,144);
  Color newGray = new Color (159,159,159);

  //UNIVERSAL VARIABLES TO BE USED__________

  //initializing String that will be numbers on circles
  String value ="0";

  int rollOne = 6;
  int rollTwo = 6;

  //hex (start[i][0],start[i][1]) you move the robber to
  int robber=0;
  boolean robberClick=false;

  //71 long, v1,v1,road?,player
  int[][] roadSide = new int[][]{
    {0,1,0,0},
    {2,3,0,0},
    {4,5,0,0},
    {7,8,0,0},
    {9,10,0,0},
    {11,12,0,0},
    {13,14,0,0},
    {16,17,0,0},
    {18,19,0,0},
    {20,21,0,0},
    {22,23,0,0},
    {24,25,0,0},
    {28,29,0,0},
    {30,31,0,0},
    {32,33,0,0},
    {34,35,0,0},
    {36,37,0,0},   
    {39,40,0,0},
    {41,42,0,0},
    {43,44,0,0},
    {45,46,0,0},   
    {48,49,0,0},
    {50,51,0,0},
    {52,53,0,0},
    {1,2,0,0},
    {3,4,0,0},
    {5,6,0,0},   
    {8,9,0,0},
    {10,11,0,0},
    {12,13,0,0},
    {14,15,0,0},
    {17,18,1,2},
    {19,20,0,0},
    {21,22,0,0},
    {23,24,0,0},
    {25,26,0,0},
    {27,28,0,0},
    {29,30,0,0},
    {31,32,0,0},
    {33,34,0,0},
    {38,39,0,0},
    {35,36,0,0},
    {40,41,0,0},
    {42,43,1,1},
    {44,45,0,0},
    {47,48,0,0},
    {49,50,0,0},
    {51,52,0,0},
    {0,8,0,0},
    {2,10,0,0},
    {4,12,0,0}, 
    {6,14,0,0},
    {7,17,0,0},
    {9,19,0,0},
    {11,21,0,0},
    {13,23,0,0},
    {15,25,0,0},
    {16,27,0,0},
    {18,29,0,0},
    {20,31,0,0},
    {22,33,0,0},
    {24,35,0,0},
    {26,37,0,0},
    {28,38,1,2},
    {30,40,0,0},
    {32,42,0,0},
    {34,44,0,0},
    {36,46,0,0},
    {39,47,0,0},
    {41,49,0,0},
    {43,51,0,0},
    {45,53,0,0}
  };

  //x,y,(nothing=0,settlement=1,city=2) [road=3),road angle1,road angle2,] currentPlayer
  int[][] vertex = new int[][]{
    {x, y-14*a,0,0},
    {x+w, y-15*a,0,0},
    {x+2*w, y-14*a,0,0},
    {x+3*w, y-15*a,0,0},
    {x+4*w, y-14*a,0,0},
    {x+5*w, y-15*a,0,0},
    {x+6*w, y-14*a,0,0},
    {x-w, y-11*a,0,0},
    {x, y-12*a,0,0},
    {x+w, y-11*a,0,0},
    {x+2*w, y-12*a,0,0},
    {x+3*w, y-11*a,0,0},
    {x+4*w, y-12*a,0,0},
    {x+5*w, y-11*a,0,0},
    {x+6*w, y-12*a,0,0},
    {x+7*w, y-11*a,1,1},
    {x-2*w, y-8*a,0,0},
    {x-w, y-9*a,0,0},
    {x, y-8*a,0,0},
    {x+w, y-9*a,0,0},
    {x+2*w, y-8*a,0,0},
    {x+3*w, y-9*a,0,0},
    {x+4*w, y-8*a,0,0},
    {x+5*w, y-9*a,0,0},
    {x+6*w, y-8*a,1,3},
    {x+7*w, y-9*a,0,0},
    {x+8*w, y-8*a,0,0},
    {x-2*w, y-6*a,0,0},
    {x-w, y-5*a,0,0},
    {x, y-6*a,0,0},
    {x+w, y-5*a,0,0},
    {x+2*w, y-6*a,0,0},
    {x+3*w, y-5*a,0,0},
    {x+4*w, y-6*a,0,0},
    {x+5*w, y-5*a,0,0},
    {x+6*w, y-6*a,0,0},
    {x+7*w, y-5*a,2,2},
    {x+8*w, y-6*a,0,0},
    {x-w, y-3*a,0,0},
    {x, y-2*a,0,0},
    {x+w, y-3*a,0,0},
    {x+2*w, y-2*a,0,0},
    {x+3*w, y-3*a,0,0},
    {x+4*w, y-2*a,0,0},
    {x+5*w, y-3*a,0,0},
    {x+6*w, y-2*a,0,0},
    {x+7*w, y-3*a,0,0},
    {x, y,0,0},
    {x+w, y+a,0,0},
    {x+2*w, y,0,0},
    {x+3*w, y+a,0,0},
    {x+4*w, y,0,0},
    {x+5*w, y+a,0,0},
    {x+6*w, y,0,0}
  };

  //array of bottom left corners of Hexagons, third is robber
  int[][] start = new int[][]{
    {x,y-12*a,0},
    {x+2*w, y-12*a,0},
    {x+4*w, y-12*a,0},
    {x-w, y-9*a,0},
    {x+w, y-9*a,0},
    {x+3*w, y-9*a,0},
    {x+5*w, y-9*a,0},
    {x-2*w, y-6*a,1},
    {x, y-6*a,0},
    {x+2*w, y-6*a,0},
    {x+4*w, y-6*a,0},
    {x+6*w, y-6*a,0},
    {x-w, y-3*a,0},
    {x+w, y-3*a,0},
    {x+3*w, y-3*a,0},
    {x+5*w, y-3*a,0},
    {x, y,0},
    {x+2*w, y,0},
    {x+4*w, y,0}
  };

  //CAN GET RID OF WHEN CONECTED__________

  //need interaction game player variable 
  int gamePlayers=4;
  //fake board
  int[][] res = new int[][]{
    {0,0},
    {5,12},
    {2,11},
    {1,8},
    {4,5},       
    {5,4},
    {3,8},
    {3,10},
    {4,10},
    {5,6},
    {5,3},
    {1,4},
    {2,6},
    {3,9},       
    {2,11},
    {1,5},
    {2,3},    
    {4,9},
    {4,4},
  };

  int[] player1 = new int[]{0,0,0,0,7,0};
  int[] player2 = new int[]{0,0,1,0,0,10};
  int[] player3 = new int[]{0,0,0,2,0,0};
  int[] player4 = new int[]{0,0,3,0,0,0};


  //sets up screen and size
  //pass the list of tiles to draw and the first player
  public Hexanew(FrontEndInterface f, int[][] board){
      setTitle("Hexanew");
      setSize(1500, 1000);
      setVisible(true);
      addMouseListener(new Clicks(this, f));
      setDefaultCloseOperation(EXIT_ON_CLOSE);
      interaction = f;
      res = board;
  }
  
  public void paint(Graphics graphics){
      g = graphics;
      //allows me to print text!
      g2 = (Graphics2D)g;
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

      drawBoard(interaction.currentPlayerID);       
      updateBoard();
  }

  public void drawBoard (int currentPlayer){
      //background
      g.setColor(circles);
      int xpoints[]={0,1500,1500,0};
      int ypoints[]={0,0,1000,1000};
      g.fillPolygon(xpoints,ypoints,4);

      //drawing border
      drawBorderHex(a1, x, y+2*a);

      //Filling in Board
      int resource=0;
      for (int i=0; i<19; i++){
        //get resource ID, will be from CJ
        resource= res[i][0];
        //Draw each small hexagon
        drawHexalex(start[i][0],start[i][1], resource);
        //Makes sure it's not the dessert
        if(resource != 0){
          g.setColor(circles);
         //circle radius is simply shifted from the left lower coordinates in start[][]
          drawCircle(start[i][0]+w, start[i][1]-a, 20);
          //Getting number for circle
          value = Integer.toString(res[i][1]);
          g.setColor(Color.black);
          //making 8 and 6 red
          if (value.equals("6") || value.equals("8")){
            g.setColor(Color.red);
          }
          //6 and five are centering text
          g2.drawString(value, start[i][0]+w-6, start[i][1]-a+5);
        }
      }

      //Setting Dice, should be from Julia
      drawDice(25, 800, rollOne, false);
      drawDice(110, 800, rollTwo, true);

      //Things to build
      //x values are pretty arbitrary, just moving things over
      drawCity(x+750-3*a, y-560, currentPlayer);
      drawSetty(x+750, y-560, currentPlayer);
      drawRoad(x+750+2*a, y-560, currentPlayer);
      drawDevelopement(3*a, x+780+4*a, y-560);
      drawCards(890, 260);
      //Setting players, should be from Julia
      drawPlayers(g2, 900, 300, gamePlayers);
  }

  public void updateBoard(){
      for (int i=0; i<71;i++){
        if(roadSide[i][2]>0){
          buildRoad(i);
        }
      }
      for (int i=0; i<54; i++){
        //checks for if there is a citty or Settlement
        if (vertex[i][2]==1){
          buildSetty(vertex[i][0],vertex[i][1], vertex[i][3]);
        }
        if (vertex[i][2]==2){
          buildCity(vertex[i][0],vertex[i][1], vertex[i][3]);
        }  
      }
      //checks where the robber is 
      for (int i=0; i<19; i++){
        if(start[i][2]==1){
          drawRobber(start[i][0], start[i][1]); 
        }
      }
      drawResources(g2, 1, player1);
      drawResources(g2, 2, player2);
      drawResources(g2, 3, player3);
      if (gamePlayers==4){
        drawResources(g2, 4, player4);       
      }
  }



  //active methods
  public void buildRoad(int v){
      double three=(((3)^(1/2))*a)/2;
      int sqrthree= (int) three;
      double two=a/(4*(2^(1/2)));
      int sqrtwo= (int) two; 

      //sets road color to player
      if(roadSide[v][3]==1){
        g.setColor(blue);
      }
      if(roadSide[v][3]==2){
        g.setColor(red);
      }
      if(roadSide[v][3]==3){
        g.setColor(orange);
      }
      if(roadSide[v][3]==4){
        g.setColor(white);
      }

      //forward slant
      int x=0;
      int y=0;
      if(v<24){
        x=vertex[roadSide[v][0]][0];
        y=vertex[roadSide[v][0]][1];
        int xpoints[] = {x+5, x+sqrthree+5, x+sqrthree-sqrtwo+7, x-sqrtwo+7};
        int ypoints[] = {y, y-a+4, y-a-sqrtwo+4, y-sqrtwo};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
      //back slant
      if (v>23 && v<48){
        x=vertex[roadSide[v][1]][0];
        y=vertex[roadSide[v][1]][1];
        int xpoints[] = {x-5, x-sqrthree-5, x-sqrthree+sqrtwo-7, x+sqrtwo-7};
        int ypoints[] = {y+2, y-a+6, y-a-sqrtwo+6, y-sqrtwo+2};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
      //Vertical
      if (v>48 && v<72){
        x=vertex[roadSide[v][1]][0];
        y=vertex[roadSide[v][1]][1];
        int xpoints[] = {x-3, x+a/4-7, x+a/4-7, x-3};
        int ypoints[] = {y-7, y-7, y-2*a+3, y-2*a+3};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void buildSetty(int x, int y, int currentPlayer){
      x=x-15;
      y=y+15;
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }
      //city
      int xpoints[] = {x, x, x+3*a/8, x+3*a/4, x+3*a/4};
      int ypoints[] = {y, y-3*a/4, y-9*a/8, y-3*a/4, y};
      int npoints = 5;

      g.fillPolygon(xpoints, ypoints, npoints);
      g.setColor(circles);
      g.drawPolygon(xpoints, ypoints, npoints);
  }

  public void buildCity(int x, int y, int currentPlayer){
      x=x-15;
      y=y+15;
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //city
      int xpoints[] = {x, x, x+3*a/8, x+3*a/4, x+3*a/4, x+3*a/2, x+3*a/2};
      int ypoints[] = {y, y-9*a/8, y-3*a/2, y-9*a/8, y-3*a/4, y-3*a/4, y};
      int npoints = 7;

      g.fillPolygon(xpoints, ypoints, npoints);
      g.setColor(circles);
      g.drawPolygon(xpoints, ypoints, npoints);
  }
  


  //interaction methods
  public void addRoad(int v1, int v2, int currentPlayer){
      for (int i=0;i<70;i++){
        if(roadSide[i][0]==v1){
          if(roadSide[i][1]==v2){
            roadSide[i][2]=1;
          }
        }
        if(roadSide[i][0]==v2){
          if(roadSide[i][1]==v1){
            roadSide[i][2]=1;
          }
        } 
        roadSide[i][3]=currentPlayer;       
      }
	  	repaint();
  }
  
  public void addSettlement(int v){
    vertex[v][2]=1;
    vertex[v][3]=interaction.currentPlayerID;
    repaint();
  }

  public void addCity(int v){
    vertex[v][2]=2;
    vertex[v][3]=interaction.currentPlayerID;
    repaint();
  }

  //will pass player and an int array with resource count 
  public void addResources(int currentPlayer, int[] resourceCount){
    //all the interaction happens here
    for(int i=1;i<6;i++){
      if (currentPlayer==1) {
        player1[i]=resourceCount[i];        
      }
      if (currentPlayer==2) {
        player2[i]=resourceCount[i];        
      }
      if (currentPlayer==3) {
        player3[i]=resourceCount[i];        
      }
      if (currentPlayer==4) {
        player4[i]=resourceCount[i];        
      }
    }
  }

  //pass the add robber method the hexagon
  public void addRobber(int h){
    for (int i=0; i<19; i++){
      if(start[i][2]==1){
        start[i][2]=0; 
      }
    }
    start[h][2]=1;
    repaint();
  }



  //all draw methods

  public void drawHexalex(int x, int y, int resource){

      //array of coordinates, starting at lower left corner of the hexagon
      int xpoints[] = {x, x, x+w, x+2*w, x+2*w, x+w};
      int ypoints[] = {y, y-2*a, y-3*a, y-2*a, y, y+a};
      int npoints = 6;

      //checks the resource and sets the appropriate color
      if (resource==0){
         g.setColor(dessert);
      }
      else if (resource==1){
         g.setColor(stone);
      }
      else if (resource==2){
         g.setColor(wheat);
      }
      else if (resource==3){
         g.setColor(brick);
      }
      else if (resource==4){
         g.setColor(wood);
      }      
      else if (resource==5){
         g.setColor(sheep);
      }
      //inputs the resource
      g.fillPolygon(xpoints, ypoints, npoints);

      //draws outline
      g.setColor(Color.white);
      g.drawPolygon(xpoints, ypoints, npoints);
  }

  public void drawBorderHex(int a1, int x, int y){

      double yTwo=y-2*a1/1.155;
      int y2= (int) yTwo;

      double ythree=y-4*a1/1.155;
      int y3= (int) ythree;

      int xpoints[] = {x, x-a1, x, x+2*a1, x+3*a1, x+2*a1};
      int ypoints[] = {y, y2, y3, y3, y2, y};
      int npoints = 6;
      
      g.setColor(water);
      g.fillPolygon(xpoints, ypoints, npoints);
  }

  public void drawDice(int x, int y, int roll, boolean yellow){
      //l must be divisible by 10 for rounding of dice
      int l = 3*a/2;
      int xpoints[] = {x, x, x+l/10, x+9*l/10, x+l, x+l, x+9*l/10, x+l/10};
      int ypoints[] = {y, y-8*l/10, y-9*l/10, y-9*l/10, y-8*l/10, y, y+l/10, y+l/10};
      int npoints = 8;
      g.setColor(Color.red);  
      if (yellow==true){
         g.setColor(Color.yellow);  
      }
      g.fillPolygon(xpoints, ypoints, npoints);

      //numbers
      int radius = 5;
      g.setColor(Color.yellow);
      if (yellow==true){
         g.setColor(Color.red);  
      }

      if (roll==1){
        drawCircle(x+l/2, y-2*l/5, radius);
      }
      if (roll==2){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==3){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/2, y-2*l/5, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==4){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==5){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/2, y-2*l/5, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==6){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/10+2*radius, y-2*l/5, radius);
        drawCircle(x+9*l/10-2*radius, y-2*l/5, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
  }

  public void drawRoad(int x, int y, int currentPlayer){
      g.setColor(blue);
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //for building a road
      int xpoints[] = {x, x, x+2*a, x+2*a};
      int ypoints[] = {y, y-a/4, y-a/4, y};
      int npoints = 4;
      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawSetty(int x, int y, int currentPlayer){
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }
      //city
      int xpoints[] = {x, x, x+a/2, x+a, x+a};
      int ypoints[] = {y, y-a, y-3*a/2, y-a, y};
      int npoints = 5;

      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawCity(int x, int y, int currentPlayer){
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //city
      int xpoints[] = {x, x, x+a/2, x+a, x+a, x+2*a, x+2*a};
      int ypoints[] = {y, y-3*a/2, y-2*a, y-3*a/2, y-a, y-a, y};
      int npoints = 7;
      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawRobber(int x, int y){
    g.setColor(robberGray);
    drawCircle(x+w, y-a, 20);
    g.setColor(newGray);
    drawCircle(x+w, y-a, 17);
    g.setColor(robberGray);
    drawCircle(x+w, y-a, 10);
  }

  public void drawDevelopement(int l, int x, int y){

          //Draw card outline
          g.setColor(Color.white);  
          drawCardOutline(3*a/2, x, y);
          //inside circles
          l=l+8;
          x=x+6*l/20-2;
          y=y-l/2+4;
          int radius=35;
          g.setColor(Color.lightGray);
          drawCircle(x, y, radius+1);
          g.setColor(brick);
          drawCircle(x, y, radius-2);
          g.setColor(darkBlue);
          g.fillArc(x+-32, y-21, radius+29, radius+19, 0, -180);
          g.setColor(darkYellow);
          drawCircle(x, y, radius-15);
          g.setColor(Color.lightGray);
          drawCircle(x, y, radius-25);
          g.setColor(stone);
          drawCircle(x, y, radius-27);
  }

  public void drawCardOutline(int l, int x, int y){
          //This b is an altered a
          int xpoints[] = {x, x-l/10, x-l/10, x, x+6*l/5, x+13*l/10, x+13*l/10,x+6*l/5};
          int ypoints[] = {y, y-l/10, y-19*l/10, y-2*l, y-2*l, y-19*l/10, y-l/10, y};
          int npoints = 8;
          g.fillPolygon(xpoints, ypoints, npoints);
  }

  public void drawCards(int x, int y){
      //Drawing cards under PLayers
      for(int j=0; j<5; j++){
        drawResourceCards(x+j*2*a, y, 5-j);
      }
  }

  public void drawResourceCards(int x, int y, int resource){
          //Setting Card Outline
          g.setColor(Color.white); 
          drawCardOutline(a, x, y);

          if (resource==1){
             g.setColor(stone);
          }
          else if (resource==2){
             g.setColor(wheat);
          }
          else if (resource==3){
             g.setColor(brick);
          }
          else if (resource==4){
             g.setColor(wood);
          }      
          else if (resource==5){
             g.setColor(sheep);
          }
          drawCardOutline(a-4, x+2, y-4);
  }
  
  public void drawPlayers(Graphics2D g2,int x, int y, int players){
      Font font = new Font("Gill Sans", Font.PLAIN, 20);
      g2.setFont(font);
      //Writes Player names
      g.setColor(blue);  
      g2.drawString("Player One", x, y);
      g.setColor(red);
      g2.drawString("Player Two", x, y+150);
      g.setColor(orange);
      g2.drawString("Player Three", x, y+300);
      //Adds fourth Player
      if(players==4){
        g.setColor(newGray);
        g2.drawString("Player Four", x, y+450);
      }  

      font = new Font("Gill Sans", Font.PLAIN, 15);
      g2.setFont(font);
      //draws cards
      g2.setColor(stone);
      for(int i=0; i<players;i++){
        g2.drawString("Sheep   ", x, y+25+i*150);
        g2.drawString("Wood    ", x, y+40+i*150); 
        g2.drawString("Brick   ", x, y+55+i*150);
        g2.drawString("Wheat   ", x, y+70+i*150);
        g2.drawString("Stone   ", x, y+85+i*150);
      }  
  }

  public void drawResources(Graphics2D g2, int currentPlayer, int[] resourceCount){
      Font font = new Font("Gill Sans", Font.PLAIN, 15);
      g2.setFont(font);
      //draws cards
      g2.setColor(stone);

      String stone = Integer.toString(resourceCount[1]);
      if(stone.equals("0")){
        stone=" ";
      }
      String wheat = Integer.toString(resourceCount[2]);
      if(wheat.equals("0")){
        wheat=" ";
      }
      String brick = Integer.toString(resourceCount[3]);
      if(brick.equals("0")){
        brick=" ";
      }
      String wood = Integer.toString(resourceCount[4]);
      if(wood.equals("0")){
        wood=" ";
      }
      String sheep = Integer.toString(resourceCount[5]);
      if(sheep.equals("0")){
        sheep=" ";
      }

      int x=950;
      int y=300;

      int i=currentPlayer-1;
      g2.drawString(sheep, x, y+25+i*150);
      g2.drawString(wood, x, y+40+i*150); 
      g2.drawString(brick, x, y+55+i*150);
      g2.drawString(wheat, x, y+70+i*150);
      g2.drawString(stone, x, y+85+i*150);

      repaint();
      
  }

  private void drawCircle(int x, int y, int radius) {
    g.fillOval(x-radius, y-radius, radius*2, radius*2);
  }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-10 13:25:24.709
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:247)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	... 17 more
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 13:25:24.711
!MESSAGE org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 13:25:24.711
!MESSAGE org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-10 13:25:24.713
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:247)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	... 17 more
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 13:25:24.713
!MESSAGE org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-10 13:40:20.218
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Graphics;
import java.awt.Polygon; 
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import javax.swing.JFrame;
import javax.swing.JPanel;
import java.awt.geom.Arc2D;
import java.awt.font.TextAttribute;
import java.awt.Font;
import java.awt.RenderingHints;

public class Hexanew extends JFrame{
  Graphics g;
  Graphics2D g2;
  FrontEndInterface interaction;

  //CONSTANT__________

  //size of each small polygol, one side=2a
  int a = 40;
  //board coordinates, at the lowest left corner of the lowest left tile, chosen for asthetics
  int x = 250;
  int y = 720;
  //width=1/2 of full width of hexagon, only initiallizing to change from double
  double width=2*a/1.155;
  int w= (int) width;
  //ratio of little hexagon side to big hexagon side, only initiallizing to change from double
  double aBorder = 6*a/1.155;
  int a1 = (int) aBorder;

  //Making colors
  Color water = new Color (54, 183, 235);
  Color brick = new Color (152, 0, 0);
  Color wood = new Color (0, 102, 0);
  Color stone = new Color (115, 115, 115);
  Color wheat = new Color (247, 244, 57);
  Color sheep = new Color (102, 255, 102);
  Color dessert = new Color (235, 177, 54);
  Color circles = new Color (255,248,220);
  Color darkBlue = new Color (0,0,204);
  Color darkYellow = new Color (219,223,93);
  Color gray = new Color (160,160,160);
  Color white = new Color (224,224,224);
  Color orange = new Color (255,128,0);
  Color blue = new Color (0,0,224);
  Color red = new Color (218,46,46);
  Color robberGray = new Color (144,144,144);
  Color newGray = new Color (159,159,159);

  //UNIVERSAL VARIABLES TO BE USED__________

  //initializing String that will be numbers on circles
  String value ="0";

  int rollOne = 6;
  int rollTwo = 6;

  //hex (start[i][0],start[i][1]) you move the robber to
  int robber=0;
  boolean robberClick=false;

  //71 long, v1,v1,road?,player
  int[][] roadSide = new int[][]{
    {0,1,0,0},
    {2,3,0,0},
    {4,5,0,0},
    {7,8,0,0},
    {9,10,0,0},
    {11,12,0,0},
    {13,14,0,0},
    {16,17,0,0},
    {18,19,0,0},
    {20,21,0,0},
    {22,23,0,0},
    {24,25,0,0},
    {28,29,0,0},
    {30,31,0,0},
    {32,33,0,0},
    {34,35,0,0},
    {36,37,0,0},   
    {39,40,0,0},
    {41,42,0,0},
    {43,44,0,0},
    {45,46,0,0},   
    {48,49,0,0},
    {50,51,0,0},
    {52,53,0,0},
    {1,2,0,0},
    {3,4,0,0},
    {5,6,0,0},   
    {8,9,0,0},
    {10,11,0,0},
    {12,13,0,0},
    {14,15,0,0},
    {17,18,1,2},
    {19,20,0,0},
    {21,22,0,0},
    {23,24,0,0},
    {25,26,0,0},
    {27,28,0,0},
    {29,30,0,0},
    {31,32,0,0},
    {33,34,0,0},
    {38,39,0,0},
    {35,36,0,0},
    {40,41,0,0},
    {42,43,1,1},
    {44,45,0,0},
    {47,48,0,0},
    {49,50,0,0},
    {51,52,0,0},
    {0,8,0,0},
    {2,10,0,0},
    {4,12,0,0}, 
    {6,14,0,0},
    {7,17,0,0},
    {9,19,0,0},
    {11,21,0,0},
    {13,23,0,0},
    {15,25,0,0},
    {16,27,0,0},
    {18,29,0,0},
    {20,31,0,0},
    {22,33,0,0},
    {24,35,0,0},
    {26,37,0,0},
    {28,38,1,2},
    {30,40,0,0},
    {32,42,0,0},
    {34,44,0,0},
    {36,46,0,0},
    {39,47,0,0},
    {41,49,0,0},
    {43,51,0,0},
    {45,53,0,0}
  };

  //x,y,(nothing=0,settlement=1,city=2) [road=3),road angle1,road angle2,] currentPlayer
  int[][] vertex = new int[][]{
    {x, y-14*a,0,0},
    {x+w, y-15*a,0,0},
    {x+2*w, y-14*a,0,0},
    {x+3*w, y-15*a,0,0},
    {x+4*w, y-14*a,0,0},
    {x+5*w, y-15*a,0,0},
    {x+6*w, y-14*a,0,0},
    {x-w, y-11*a,0,0},
    {x, y-12*a,0,0},
    {x+w, y-11*a,0,0},
    {x+2*w, y-12*a,0,0},
    {x+3*w, y-11*a,0,0},
    {x+4*w, y-12*a,0,0},
    {x+5*w, y-11*a,0,0},
    {x+6*w, y-12*a,0,0},
    {x+7*w, y-11*a,1,1},
    {x-2*w, y-8*a,0,0},
    {x-w, y-9*a,0,0},
    {x, y-8*a,0,0},
    {x+w, y-9*a,0,0},
    {x+2*w, y-8*a,0,0},
    {x+3*w, y-9*a,0,0},
    {x+4*w, y-8*a,0,0},
    {x+5*w, y-9*a,0,0},
    {x+6*w, y-8*a,1,3},
    {x+7*w, y-9*a,0,0},
    {x+8*w, y-8*a,0,0},
    {x-2*w, y-6*a,0,0},
    {x-w, y-5*a,0,0},
    {x, y-6*a,0,0},
    {x+w, y-5*a,0,0},
    {x+2*w, y-6*a,0,0},
    {x+3*w, y-5*a,0,0},
    {x+4*w, y-6*a,0,0},
    {x+5*w, y-5*a,0,0},
    {x+6*w, y-6*a,0,0},
    {x+7*w, y-5*a,2,2},
    {x+8*w, y-6*a,0,0},
    {x-w, y-3*a,0,0},
    {x, y-2*a,0,0},
    {x+w, y-3*a,0,0},
    {x+2*w, y-2*a,0,0},
    {x+3*w, y-3*a,0,0},
    {x+4*w, y-2*a,0,0},
    {x+5*w, y-3*a,0,0},
    {x+6*w, y-2*a,0,0},
    {x+7*w, y-3*a,0,0},
    {x, y,0,0},
    {x+w, y+a,0,0},
    {x+2*w, y,0,0},
    {x+3*w, y+a,0,0},
    {x+4*w, y,0,0},
    {x+5*w, y+a,0,0},
    {x+6*w, y,0,0}
  };

  //array of bottom left corners of Hexagons, third is robber
  int[][] start = new int[][]{
    {x,y-12*a,0},
    {x+2*w, y-12*a,0},
    {x+4*w, y-12*a,0},
    {x-w, y-9*a,0},
    {x+w, y-9*a,0},
    {x+3*w, y-9*a,0},
    {x+5*w, y-9*a,0},
    {x-2*w, y-6*a,1},
    {x, y-6*a,0},
    {x+2*w, y-6*a,0},
    {x+4*w, y-6*a,0},
    {x+6*w, y-6*a,0},
    {x-w, y-3*a,0},
    {x+w, y-3*a,0},
    {x+3*w, y-3*a,0},
    {x+5*w, y-3*a,0},
    {x, y,0},
    {x+2*w, y,0},
    {x+4*w, y,0}
  };

  //CAN GET RID OF WHEN CONECTED__________

  //need interaction game player variable 
  int gamePlayers=4;
  //fake board
  int[][] res = new int[][]{
    {0,0},
    {5,12},
    {2,11},
    {1,8},
    {4,5},       
    {5,4},
    {3,8},
    {3,10},
    {4,10},
    {5,6},
    {5,3},
    {1,4},
    {2,6},
    {3,9},       
    {2,11},
    {1,5},
    {2,3},    
    {4,9},
    {4,4},
  };

  int[] player1 = new int[]{0,0,0,0,7,0};
  int[] player2 = new int[]{0,0,1,0,0,10};
  int[] player3 = new int[]{0,0,0,2,0,0};
  int[] player4 = new int[]{0,0,3,0,0,0};


  //sets up screen and size
  //pass the list of tiles to draw and the first player
  public Hexanew(FrontEndInterface f, int[][] board){
      setTitle("Hexanew");
      setSize(1500, 1000);
      setVisible(true);
      addMouseListener(new Clicks(this, f));
      setDefaultCloseOperation(EXIT_ON_CLOSE);
      interaction = f;
      res = board;
  }
  
  public void paint(Graphics graphics){
      g = graphics;
      //allows me to print text!
      g2 = (Graphics2D)g;
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

      drawBoard(interaction.currentPlayerID);       
      updateBoard();
  }

  public void drawBoard (int currentPlayer){
      //background
      g.setColor(circles);
      int xpoints[]={0,1500,1500,0};
      int ypoints[]={0,0,1000,1000};
      g.fillPolygon(xpoints,ypoints,4);

      //drawing border
      drawBorderHex(a1, x, y+2*a);

      //Filling in Board
      int resource=0;
      for (int i=0; i<19; i++){
        //get resource ID, will be from CJ
        resource= res[i][0];
        //Draw each small hexagon
        drawHexalex(start[i][0],start[i][1], resource);
        //Makes sure it's not the dessert
        if(resource != 0){
          g.setColor(circles);
         //circle radius is simply shifted from the left lower coordinates in start[][]
          drawCircle(start[i][0]+w, start[i][1]-a, 20);
          //Getting number for circle
          value = Integer.toString(res[i][1]);
          g.setColor(Color.black);
          //making 8 and 6 red
          if (value.equals("6") || value.equals("8")){
            g.setColor(Color.red);
          }
          //6 and five are centering text
          g2.drawString(value, start[i][0]+w-6, start[i][1]-a+5);
        }
      }

      //Setting Dice, should be from Julia
      drawDice(25, 800, rollOne, false);
      drawDice(110, 800, rollTwo, true);

      //Things to build
      //x values are pretty arbitrary, just moving things over
      drawCity(x+750-3*a, y-560, currentPlayer);
      drawSetty(x+750, y-560, currentPlayer);
      drawRoad(x+750+2*a, y-560, currentPlayer);
      drawDevelopement(3*a, x+780+4*a, y-560);
      drawCards(890, 260);
      //Setting players, should be from Julia
      drawPlayers(g2, 900, 300, gamePlayers);
  }

  public void updateBoard(){
      for (int i=0; i<71;i++){
        if(roadSide[i][2]>0){
          buildRoad(i);
        }
      }
      for (int i=0; i<54; i++){
        //checks for if there is a citty or Settlement
        if (vertex[i][2]==1){
          buildSetty(vertex[i][0],vertex[i][1], vertex[i][3]);
        }
        if (vertex[i][2]==2){
          buildCity(vertex[i][0],vertex[i][1], vertex[i][3]);
        }  
      }
      //checks where the robber is 
      for (int i=0; i<19; i++){
        if(start[i][2]==1){
          drawRobber(start[i][0], start[i][1]); 
        }
      }
      drawResources(g2, 1, player1);
      drawResources(g2, 2, player2);
      drawResources(g2, 3, player3);
      if (gamePlayers==4){
        drawResources(g2, 4, player4);       
      }
  }



  //active methods
  public void buildRoad(int v){
      double three=(((3)^(1/2))*a)/2;
      int sqrthree= (int) three;
      double two=a/(4*(2^(1/2)));
      int sqrtwo= (int) two; 

      //sets road color to player
      if(roadSide[v][3]==1){
        g.setColor(blue);
      }
      if(roadSide[v][3]==2){
        g.setColor(red);
      }
      if(roadSide[v][3]==3){
        g.setColor(orange);
      }
      if(roadSide[v][3]==4){
        g.setColor(white);
      }

      //forward slant
      int x=0;
      int y=0;
      if(v<24){
        x=vertex[roadSide[v][0]][0];
        y=vertex[roadSide[v][0]][1];
        int xpoints[] = {x+5, x+sqrthree+5, x+sqrthree-sqrtwo+7, x-sqrtwo+7};
        int ypoints[] = {y, y-a+4, y-a-sqrtwo+4, y-sqrtwo};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
      //back slant
      if (v>23 && v<48){
        x=vertex[roadSide[v][1]][0];
        y=vertex[roadSide[v][1]][1];
        int xpoints[] = {x-5, x-sqrthree-5, x-sqrthree+sqrtwo-7, x+sqrtwo-7};
        int ypoints[] = {y+2, y-a+6, y-a-sqrtwo+6, y-sqrtwo+2};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
      //Vertical
      if (v>48 && v<72){
        x=vertex[roadSide[v][1]][0];
        y=vertex[roadSide[v][1]][1];
        int xpoints[] = {x-3, x+a/4-7, x+a/4-7, x-3};
        int ypoints[] = {y-7, y-7, y-2*a+3, y-2*a+3};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void buildSetty(int x, int y, int currentPlayer){
      x=x-15;
      y=y+15;
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }
      //city
      int xpoints[] = {x, x, x+3*a/8, x+3*a/4, x+3*a/4};
      int ypoints[] = {y, y-3*a/4, y-9*a/8, y-3*a/4, y};
      int npoints = 5;

      g.fillPolygon(xpoints, ypoints, npoints);
      g.setColor(circles);
      g.drawPolygon(xpoints, ypoints, npoints);
  }

  public void buildCity(int x, int y, int currentPlayer){
      x=x-15;
      y=y+15;
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //city
      int xpoints[] = {x, x, x+3*a/8, x+3*a/4, x+3*a/4, x+3*a/2, x+3*a/2};
      int ypoints[] = {y, y-9*a/8, y-3*a/2, y-9*a/8, y-3*a/4, y-3*a/4, y};
      int npoints = 7;

      g.fillPolygon(xpoints, ypoints, npoints);
      g.setColor(circles);
      g.drawPolygon(xpoints, ypoints, npoints);
  }
  


  //interaction methods
  public void addRoad(int v1, int v2, int currentPlayer){
      for (int i=0;i<70;i++){
        if(roadSide[i][0]==v1){
          if(roadSide[i][1]==v2){
            roadSide[i][2]=1;
          }
        }
        if(roadSide[i][0]==v2){
          if(roadSide[i][1]==v1){
            roadSide[i][2]=1;
          }
        } 
        roadSide[i][3]=currentPlayer;       
      }
	  	repaint();
  }
  
  public void addSettlement(int v){
    vertex[v][2]=1;
    vertex[v][3]=interaction.currentPlayerID;
    repaint();
  }

  public void addCity(int v){
    vertex[v][2]=2;
    vertex[v][3]=interaction.currentPlayerID;
    repaint();
  }

  //will pass player and an int array with resource count 
  public void addResources(int currentPlayer, int[] resourceCount){
    //all the interaction happens here
    for(int i=1;i<6;i++){
      if (currentPlayer==1) {
        player1[i]=resourceCount[i];        
      }
      if (currentPlayer==2) {
        player2[i]=resourceCount[i];        
      }
      if (currentPlayer==3) {
        player3[i]=resourceCount[i];        
      }
      if (currentPlayer==4) {
        player4[i]=resourceCount[i];        
      }
    }
  }

  //pass the add robber method the hexagon
  public void addRobber(int h){
    for (int i=0; i<19; i++){
      if(start[i][2]==1){
        start[i][2]=0; 
      }
    }
    start[h][2]=1;
    repaint();
  }



  //all draw methods

  public void drawHexalex(int x, int y, int resource){

      //array of coordinates, starting at lower left corner of the hexagon
      int xpoints[] = {x, x, x+w, x+2*w, x+2*w, x+w};
      int ypoints[] = {y, y-2*a, y-3*a, y-2*a, y, y+a};
      int npoints = 6;

      //checks the resource and sets the appropriate color
      if (resource==0){
         g.setColor(dessert);
      }
      else if (resource==1){
         g.setColor(stone);
      }
      else if (resource==2){
         g.setColor(wheat);
      }
      else if (resource==3){
         g.setColor(brick);
      }
      else if (resource==4){
         g.setColor(wood);
      }      
      else if (resource==5){
         g.setColor(sheep);
      }
      //inputs the resource
      g.fillPolygon(xpoints, ypoints, npoints);

      //draws outline
      g.setColor(Color.white);
      g.drawPolygon(xpoints, ypoints, npoints);
  }

  public void drawBorderHex(int a1, int x, int y){

      double yTwo=y-2*a1/1.155;
      int y2= (int) yTwo;

      double ythree=y-4*a1/1.155;
      int y3= (int) ythree;

      int xpoints[] = {x, x-a1, x, x+2*a1, x+3*a1, x+2*a1};
      int ypoints[] = {y, y2, y3, y3, y2, y};
      int npoints = 6;
      
      g.setColor(water);
      g.fillPolygon(xpoints, ypoints, npoints);
  }

  public void drawDice(int x, int y, int roll, boolean yellow){
      //l must be divisible by 10 for rounding of dice
      int l = 3*a/2;
      int xpoints[] = {x, x, x+l/10, x+9*l/10, x+l, x+l, x+9*l/10, x+l/10};
      int ypoints[] = {y, y-8*l/10, y-9*l/10, y-9*l/10, y-8*l/10, y, y+l/10, y+l/10};
      int npoints = 8;
      g.setColor(Color.red);  
      if (yellow==true){
         g.setColor(Color.yellow);  
      }
      g.fillPolygon(xpoints, ypoints, npoints);

      //numbers
      int radius = 5;
      g.setColor(Color.yellow);
      if (yellow==true){
         g.setColor(Color.red);  
      }

      if (roll==1){
        drawCircle(x+l/2, y-2*l/5, radius);
      }
      if (roll==2){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==3){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/2, y-2*l/5, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==4){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==5){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/2, y-2*l/5, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==6){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/10+2*radius, y-2*l/5, radius);
        drawCircle(x+9*l/10-2*radius, y-2*l/5, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
  }

  public void drawRoad(int x, int y, int currentPlayer){
      g.setColor(blue);
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //for building a road
      int xpoints[] = {x, x, x+2*a, x+2*a};
      int ypoints[] = {y, y-a/4, y-a/4, y};
      int npoints = 4;
      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawSetty(int x, int y, int currentPlayer){
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }
      //city
      int xpoints[] = {x, x, x+a/2, x+a, x+a};
      int ypoints[] = {y, y-a, y-3*a/2, y-a, y};
      int npoints = 5;

      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawCity(int x, int y, int currentPlayer){
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //city
      int xpoints[] = {x, x, x+a/2, x+a, x+a, x+2*a, x+2*a};
      int ypoints[] = {y, y-3*a/2, y-2*a, y-3*a/2, y-a, y-a, y};
      int npoints = 7;
      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawRobber(int x, int y){
    g.setColor(robberGray);
    drawCircle(x+w, y-a, 20);
    g.setColor(newGray);
    drawCircle(x+w, y-a, 17);
    g.setColor(robberGray);
    drawCircle(x+w, y-a, 10);
  }

  public void drawDevelopement(int l, int x, int y){

          //Draw card outline
          g.setColor(Color.white);  
          drawCardOutline(3*a/2, x, y);
          //inside circles
          l=l+8;
          x=x+6*l/20-2;
          y=y-l/2+4;
          int radius=35;
          g.setColor(Color.lightGray);
          drawCircle(x, y, radius+1);
          g.setColor(brick);
          drawCircle(x, y, radius-2);
          g.setColor(darkBlue);
          g.fillArc(x+-32, y-21, radius+29, radius+19, 0, -180);
          g.setColor(darkYellow);
          drawCircle(x, y, radius-15);
          g.setColor(Color.lightGray);
          drawCircle(x, y, radius-25);
          g.setColor(stone);
          drawCircle(x, y, radius-27);
  }

  public void drawCardOutline(int l, int x, int y){
          //This b is an altered a
          int xpoints[] = {x, x-l/10, x-l/10, x, x+6*l/5, x+13*l/10, x+13*l/10,x+6*l/5};
          int ypoints[] = {y, y-l/10, y-19*l/10, y-2*l, y-2*l, y-19*l/10, y-l/10, y};
          int npoints = 8;
          g.fillPolygon(xpoints, ypoints, npoints);
  }

  public void drawCards(int x, int y){
      //Drawing cards under PLayers
      for(int j=0; j<5; j++){
        drawResourceCards(x+j*2*a, y, 5-j);
      }
  }

  public void drawResourceCards(int x, int y, int resource){
          //Setting Card Outline
          g.setColor(Color.white); 
          drawCardOutline(a, x, y);

          if (resource==1){
             g.setColor(stone);
          }
          else if (resource==2){
             g.setColor(wheat);
          }
          else if (resource==3){
             g.setColor(brick);
          }
          else if (resource==4){
             g.setColor(wood);
          }      
          else if (resource==5){
             g.setColor(sheep);
          }
          drawCardOutline(a-4, x+2, y-4);
  }
  
  public void drawPlayers(Graphics2D g2,int x, int y, int players){
      Font font = new Font("Gill Sans", Font.PLAIN, 20);
      g2.setFont(font);
      //Writes Player names
      g.setColor(blue);  
      g2.drawString("Player One", x, y);
      g.setColor(red);
      g2.drawString("Player Two", x, y+150);
      g.setColor(orange);
      g2.drawString("Player Three", x, y+300);
      //Adds fourth Player
      if(players==4){
        g.setColor(newGray);
        g2.drawString("Player Four", x, y+450);
      }  

      font = new Font("Gill Sans", Font.PLAIN, 15);
      g2.setFont(font);
      //draws cards
      g2.setColor(stone);
      for(int i=0; i<players;i++){
        g2.drawString("Sheep   ", x, y+25+i*150);
        g2.drawString("Wood    ", x, y+40+i*150); 
        g2.drawString("Brick   ", x, y+55+i*150);
        g2.drawString("Wheat   ", x, y+70+i*150);
        g2.drawString("Stone   ", x, y+85+i*150);
      }  
  }

  public void drawResources(Graphics2D g2, int currentPlayer, int[] resourceCount){
      Font font = new Font("Gill Sans", Font.PLAIN, 15);
      g2.setFont(font);
      //draws cards
      g2.setColor(stone);

      String stone = Integer.toString(resourceCount[1]);
      if(stone.equals("0")){
        stone=" ";
      }
      String wheat = Integer.toString(resourceCount[2]);
      if(wheat.equals("0")){
        wheat=" ";
      }
      String brick = Integer.toString(resourceCount[3]);
      if(brick.equals("0")){
        brick=" ";
      }
      String wood = Integer.toString(resourceCount[4]);
      if(wood.equals("0")){
        wood=" ";
      }
      String sheep = Integer.toString(resourceCount[5]);
      if(sheep.equals("0")){
        sheep=" ";
      }

      int x=950;
      int y=300;

      int i=currentPlayer-1;
      g2.drawString(sheep, x, y+25+i*150);
      g2.drawString(wood, x, y+40+i*150); 
      g2.drawString(brick, x, y+55+i*150);
      g2.drawString(wheat, x, y+70+i*150);
      g2.drawString(stone, x, y+85+i*150);

      repaint();
      
  }

  private void drawCircle(int x, int y, int radius) {
    g.fillOval(x-radius, y-radius, radius*2, radius*2);
  }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-10 13:40:20.220
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:247)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	... 16 more
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 13:40:20.220
!MESSAGE org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 13:40:20.220
!MESSAGE org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-10 13:40:20.221
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:247)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	... 16 more
Caused by: java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 13:40:20.221
!MESSAGE org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:913)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:958)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:203)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-10 13:40:20.265
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1191)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:681)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1181)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-10 13:40:20.267
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.ClassFile cannot be cast to org.eclipse.jdt.core.ICompilationUnit
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1090)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:989)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:778)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:662)
	at org.eclipse.jdt.internal.core.NameLookup.findType(NameLookup.java:621)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.find(SearchableEnvironment.java:103)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findType(SearchableEnvironment.java:294)
	at org.eclipse.jdt.internal.core.CancelableNameEnvironment.findType(CancelableNameEnvironment.java:45)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:136)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:183)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2688)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2405)
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:132)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:204)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:263)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:374)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:947)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:456)
	at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.resolveStatements(ConstructorDeclaration.java:510)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:415)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1148)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1258)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:539)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1191)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:681)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1181)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-10 14:38:33.516
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Graphics;
import java.awt.Polygon; 
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import javax.swing.JFrame;
import javax.swing.JPanel;
import java.awt.geom.Arc2D;
import java.awt.font.TextAttribute;
import java.awt.Font;
import java.awt.RenderingHints;

public class Hexanew extends JFrame{
  Graphics g;
  Graphics2D g2;
  FrontEndInterface interaction;

  //CONSTANT__________

  //size of each small polygol, one side=2a
  int a = 40;
  //board coordinates, at the lowest left corner of the lowest left tile, chosen for asthetics
  int x = 250;
  int y = 720;
  //width=1/2 of full width of hexagon, only initiallizing to change from double
  double width=2*a/1.155;
  int w= (int) width;
  //ratio of little hexagon side to big hexagon side, only initiallizing to change from double
  double aBorder = 6*a/1.155;
  int a1 = (int) aBorder;

  //Making colors
  Color water = new Color (54, 183, 235);
  Color brick = new Color (152, 0, 0);
  Color wood = new Color (0, 102, 0);
  Color stone = new Color (115, 115, 115);
  Color wheat = new Color (247, 244, 57);
  Color sheep = new Color (102, 255, 102);
  Color dessert = new Color (235, 177, 54);
  Color circles = new Color (255,248,220);
  Color darkBlue = new Color (0,0,204);
  Color darkYellow = new Color (219,223,93);
  Color gray = new Color (160,160,160);
  Color white = new Color (224,224,224);
  Color orange = new Color (255,128,0);
  Color blue = new Color (0,0,224);
  Color red = new Color (218,46,46);
  Color robberGray = new Color (144,144,144);
  Color newGray = new Color (159,159,159);

  //UNIVERSAL VARIABLES TO BE USED__________

  //initializing String that will be numbers on circles
  String value ="0";

  int rollOne = 6;
  int rollTwo = 6;

  //hex (start[i][0],start[i][1]) you move the robber to
  int robber=0;
  boolean robberClick=false;

  //71 long, v1,v1,road?,player
  int[][] roadSide = new int[][]{
    {0,1,0,0},
    {2,3,0,0},
    {4,5,0,0},
    {7,8,0,0},
    {9,10,0,0},
    {11,12,0,0},
    {13,14,0,0},
    {16,17,0,0},
    {18,19,0,0},
    {20,21,0,0},
    {22,23,0,0},
    {24,25,0,0},
    {28,29,0,0},
    {30,31,0,0},
    {32,33,0,0},
    {34,35,0,0},
    {36,37,0,0},   
    {39,40,0,0},
    {41,42,0,0},
    {43,44,0,0},
    {45,46,0,0},   
    {48,49,0,0},
    {50,51,0,0},
    {52,53,0,0},
    {1,2,0,0},
    {3,4,0,0},
    {5,6,0,0},   
    {8,9,0,0},
    {10,11,0,0},
    {12,13,0,0},
    {14,15,0,0},
    {17,18,1,2},
    {19,20,0,0},
    {21,22,0,0},
    {23,24,0,0},
    {25,26,0,0},
    {27,28,0,0},
    {29,30,0,0},
    {31,32,0,0},
    {33,34,0,0},
    {38,39,0,0},
    {35,36,0,0},
    {40,41,0,0},
    {42,43,1,1},
    {44,45,0,0},
    {47,48,0,0},
    {49,50,0,0},
    {51,52,0,0},
    {0,8,0,0},
    {2,10,0,0},
    {4,12,0,0}, 
    {6,14,0,0},
    {7,17,0,0},
    {9,19,0,0},
    {11,21,0,0},
    {13,23,0,0},
    {15,25,0,0},
    {16,27,0,0},
    {18,29,0,0},
    {20,31,0,0},
    {22,33,0,0},
    {24,35,0,0},
    {26,37,0,0},
    {28,38,1,2},
    {30,40,0,0},
    {32,42,0,0},
    {34,44,0,0},
    {36,46,0,0},
    {39,47,0,0},
    {41,49,0,0},
    {43,51,0,0},
    {45,53,0,0}
  };

  //x,y,(nothing=0,settlement=1,city=2) [road=3),road angle1,road angle2,] currentPlayer
  int[][] vertex = new int[][]{
    {x, y-14*a,0,0},
    {x+w, y-15*a,0,0},
    {x+2*w, y-14*a,0,0},
    {x+3*w, y-15*a,0,0},
    {x+4*w, y-14*a,0,0},
    {x+5*w, y-15*a,0,0},
    {x+6*w, y-14*a,0,0},
    {x-w, y-11*a,0,0},
    {x, y-12*a,0,0},
    {x+w, y-11*a,0,0},
    {x+2*w, y-12*a,0,0},
    {x+3*w, y-11*a,0,0},
    {x+4*w, y-12*a,0,0},
    {x+5*w, y-11*a,0,0},
    {x+6*w, y-12*a,0,0},
    {x+7*w, y-11*a,1,1},
    {x-2*w, y-8*a,0,0},
    {x-w, y-9*a,0,0},
    {x, y-8*a,0,0},
    {x+w, y-9*a,0,0},
    {x+2*w, y-8*a,0,0},
    {x+3*w, y-9*a,0,0},
    {x+4*w, y-8*a,0,0},
    {x+5*w, y-9*a,0,0},
    {x+6*w, y-8*a,1,3},
    {x+7*w, y-9*a,0,0},
    {x+8*w, y-8*a,0,0},
    {x-2*w, y-6*a,0,0},
    {x-w, y-5*a,0,0},
    {x, y-6*a,0,0},
    {x+w, y-5*a,0,0},
    {x+2*w, y-6*a,0,0},
    {x+3*w, y-5*a,0,0},
    {x+4*w, y-6*a,0,0},
    {x+5*w, y-5*a,0,0},
    {x+6*w, y-6*a,0,0},
    {x+7*w, y-5*a,2,2},
    {x+8*w, y-6*a,0,0},
    {x-w, y-3*a,0,0},
    {x, y-2*a,0,0},
    {x+w, y-3*a,0,0},
    {x+2*w, y-2*a,0,0},
    {x+3*w, y-3*a,0,0},
    {x+4*w, y-2*a,0,0},
    {x+5*w, y-3*a,0,0},
    {x+6*w, y-2*a,0,0},
    {x+7*w, y-3*a,0,0},
    {x, y,0,0},
    {x+w, y+a,0,0},
    {x+2*w, y,0,0},
    {x+3*w, y+a,0,0},
    {x+4*w, y,0,0},
    {x+5*w, y+a,0,0},
    {x+6*w, y,0,0}
  };

  //array of bottom left corners of Hexagons, third is robber
  int[][] start = new int[][]{
    {x,y-12*a,0},
    {x+2*w, y-12*a,0},
    {x+4*w, y-12*a,0},
    {x-w, y-9*a,0},
    {x+w, y-9*a,0},
    {x+3*w, y-9*a,0},
    {x+5*w, y-9*a,0},
    {x-2*w, y-6*a,1},
    {x, y-6*a,0},
    {x+2*w, y-6*a,0},
    {x+4*w, y-6*a,0},
    {x+6*w, y-6*a,0},
    {x-w, y-3*a,0},
    {x+w, y-3*a,0},
    {x+3*w, y-3*a,0},
    {x+5*w, y-3*a,0},
    {x, y,0},
    {x+2*w, y,0},
    {x+4*w, y,0}
  };

  //CAN GET RID OF WHEN CONECTED__________

  //need interaction game player variable 
  int gamePlayers=4;
  //fake board
  int[][] res = new int[][]{
    {0,0},
    {5,12},
    {2,11},
    {1,8},
    {4,5},       
    {5,4},
    {3,8},
    {3,10},
    {4,10},
    {5,6},
    {5,3},
    {1,4},
    {2,6},
    {3,9},       
    {2,11},
    {1,5},
    {2,3},    
    {4,9},
    {4,4},
  };

  int[] player1 = new int[]{0,0,0,0,7,0};
  int[] player2 = new int[]{0,0,1,0,0,10};
  int[] player3 = new int[]{0,0,0,2,0,0};
  int[] player4 = new int[]{0,0,3,0,0,0};


  //sets up screen and size
  //pass the list of tiles to draw and the first player
  public Hexanew(FrontEndInterface f, int[][] board){
      setTitle("Hexanew");
      setSize(1500, 1000);
      setVisible(true);
      addMouseListener(new Clicks(this, f));
      setDefaultCloseOperation(EXIT_ON_CLOSE);
      interaction = f;
      res = board;
  }
  
  public void paint(Graphics graphics){
      g = graphics;
      //allows me to print text!
      g2 = (Graphics2D)g;
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

      drawBoard(interaction.currentPlayerID);       
      updateBoard();
  }

  public void drawBoard (int currentPlayer){
      //background
      g.setColor(circles);
      int xpoints[]={0,1500,1500,0};
      int ypoints[]={0,0,1000,1000};
      g.fillPolygon(xpoints,ypoints,4);

      //drawing border
      drawBorderHex(a1, x, y+2*a);

      //Filling in Board
      int resource=0;
      for (int i=0; i<19; i++){
        //get resource ID, will be from CJ
        resource= res[i][0];
        //Draw each small hexagon
        drawHexalex(start[i][0],start[i][1], resource);
        //Makes sure it's not the dessert
        if(resource != 0){
          g.setColor(circles);
         //circle radius is simply shifted from the left lower coordinates in start[][]
          drawCircle(start[i][0]+w, start[i][1]-a, 20);
          //Getting number for circle
          value = Integer.toString(res[i][1]);
          g.setColor(Color.black);
          //making 8 and 6 red
          if (value.equals("6") || value.equals("8")){
            g.setColor(Color.red);
          }
          //6 and five are centering text
          g2.drawString(value, start[i][0]+w-6, start[i][1]-a+5);
        }
      }

      //Setting Dice, should be from Julia
      drawDice(25, 800, rollOne, false);
      drawDice(110, 800, rollTwo, true);

      //Things to build
      //x values are pretty arbitrary, just moving things over
      drawCity(x+750-3*a, y-560, currentPlayer);
      drawSetty(x+750, y-560, currentPlayer);
      drawRoad(x+750+2*a, y-560, currentPlayer);
      drawDevelopement(3*a, x+780+4*a, y-560);
      drawCards(890, 260);
      //Setting players, should be from Julia
      drawPlayers(g2, 900, 300, gamePlayers);
  }

  public void updateBoard(){
      for (int i=0; i<71;i++){
        if(roadSide[i][2]>0){
          buildRoad(i);
        }
      }
      for (int i=0; i<54; i++){
        //checks for if there is a citty or Settlement
        if (vertex[i][2]==1){
          buildSetty(vertex[i][0],vertex[i][1], vertex[i][3]);
        }
        if (vertex[i][2]==2){
          buildCity(vertex[i][0],vertex[i][1], vertex[i][3]);
        }  
      }
      //checks where the robber is 
      for (int i=0; i<19; i++){
        if(start[i][2]==1){
          drawRobber(start[i][0], start[i][1]); 
        }
      }
      drawResources(g2, 1, player1);
      drawResources(g2, 2, player2);
      drawResources(g2, 3, player3);
      if (gamePlayers==4){
        drawResources(g2, 4, player4);       
      }
  }



  //active methods
  public void buildRoad(int v){
      double three=(((3)^(1/2))*a)/2;
      int sqrthree= (int) three;
      double two=a/(4*(2^(1/2)));
      int sqrtwo= (int) two; 

      //sets road color to player
      if(roadSide[v][3]==1){
        g.setColor(blue);
      }
      if(roadSide[v][3]==2){
        g.setColor(red);
      }
      if(roadSide[v][3]==3){
        g.setColor(orange);
      }
      if(roadSide[v][3]==4){
        g.setColor(white);
      }

      //forward slant
      int x=0;
      int y=0;
      if(v<24){
        x=vertex[roadSide[v][0]][0];
        y=vertex[roadSide[v][0]][1];
        int xpoints[] = {x+5, x+sqrthree+5, x+sqrthree-sqrtwo+7, x-sqrtwo+7};
        int ypoints[] = {y, y-a+4, y-a-sqrtwo+4, y-sqrtwo};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
      //back slant
      if (v>23 && v<48){
        x=vertex[roadSide[v][1]][0];
        y=vertex[roadSide[v][1]][1];
        int xpoints[] = {x-5, x-sqrthree-5, x-sqrthree+sqrtwo-7, x+sqrtwo-7};
        int ypoints[] = {y+2, y-a+6, y-a-sqrtwo+6, y-sqrtwo+2};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
      //Vertical
      if (v>48 && v<72){
        x=vertex[roadSide[v][1]][0];
        y=vertex[roadSide[v][1]][1];
        int xpoints[] = {x-3, x+a/4-7, x+a/4-7, x-3};
        int ypoints[] = {y-7, y-7, y-2*a+3, y-2*a+3};
        int npoints = 4;
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(circles);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void buildSetty(int x, int y, int currentPlayer){
      x=x-15;
      y=y+15;
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }
      //city
      int xpoints[] = {x, x, x+3*a/8, x+3*a/4, x+3*a/4};
      int ypoints[] = {y, y-3*a/4, y-9*a/8, y-3*a/4, y};
      int npoints = 5;

      g.fillPolygon(xpoints, ypoints, npoints);
      g.setColor(circles);
      g.drawPolygon(xpoints, ypoints, npoints);
  }

  public void buildCity(int x, int y, int currentPlayer){
      x=x-15;
      y=y+15;
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //city
      int xpoints[] = {x, x, x+3*a/8, x+3*a/4, x+3*a/4, x+3*a/2, x+3*a/2};
      int ypoints[] = {y, y-9*a/8, y-3*a/2, y-9*a/8, y-3*a/4, y-3*a/4, y};
      int npoints = 7;

      g.fillPolygon(xpoints, ypoints, npoints);
      g.setColor(circles);
      g.drawPolygon(xpoints, ypoints, npoints);
  }
  


  //interaction methods
  public void addRoad(int v1, int v2, int currentPlayer){
      for (int i=0;i<70;i++){
        if(roadSide[i][0]==v1){
          if(roadSide[i][1]==v2){
            roadSide[i][2]=1;
          }
        }
        if(roadSide[i][0]==v2){
          if(roadSide[i][1]==v1){
            roadSide[i][2]=1;
          }
        } 
        roadSide[i][3]=currentPlayer;       
      }
	  	repaint();
  }
  
  public void addSettlement(int v){
    vertex[v][2]=1;
    vertex[v][3]=interaction.currentPlayerID;
    repaint();
  }

  public void addCity(int v){
    vertex[v][2]=2;
    vertex[v][3]=interaction.currentPlayerID;
    repaint();
  }

  //will pass player and an int array with resource count 
  public void addResources(int currentPlayer, int[] resourceCount){
    //all the interaction happens here
    for(int i=1;i<6;i++){
      if (currentPlayer==1) {
        player1[i]=resourceCount[i];        
      }
      if (currentPlayer==2) {
        player2[i]=resourceCount[i];        
      }
      if (currentPlayer==3) {
        player3[i]=resourceCount[i];        
      }
      if (currentPlayer==4) {
        player4[i]=resourceCount[i];        
      }
    }
  }

  //pass the add robber method the hexagon
  public void addRobber(int h){
    for (int i=0; i<19; i++){
      if(start[i][2]==1){
        start[i][2]=0; 
      }
    }
    start[h][2]=1;
    repaint();
  }



  //all draw methods

  public void drawHexalex(int x, int y, int resource){

      //array of coordinates, starting at lower left corner of the hexagon
      int xpoints[] = {x, x, x+w, x+2*w, x+2*w, x+w};
      int ypoints[] = {y, y-2*a, y-3*a, y-2*a, y, y+a};
      int npoints = 6;

      //checks the resource and sets the appropriate color
      if (resource==0){
         g.setColor(dessert);
      }
      else if (resource==1){
         g.setColor(stone);
      }
      else if (resource==2){
         g.setColor(wheat);
      }
      else if (resource==3){
         g.setColor(brick);
      }
      else if (resource==4){
         g.setColor(wood);
      }      
      else if (resource==5){
         g.setColor(sheep);
      }
      //inputs the resource
      g.fillPolygon(xpoints, ypoints, npoints);

      //draws outline
      g.setColor(Color.white);
      g.drawPolygon(xpoints, ypoints, npoints);
  }

  public void drawBorderHex(int a1, int x, int y){

      double yTwo=y-2*a1/1.155;
      int y2= (int) yTwo;

      double ythree=y-4*a1/1.155;
      int y3= (int) ythree;

      int xpoints[] = {x, x-a1, x, x+2*a1, x+3*a1, x+2*a1};
      int ypoints[] = {y, y2, y3, y3, y2, y};
      int npoints = 6;
      
      g.setColor(water);
      g.fillPolygon(xpoints, ypoints, npoints);
  }

  public void drawDice(int x, int y, int roll, boolean yellow){
      //l must be divisible by 10 for rounding of dice
      int l = 3*a/2;
      int xpoints[] = {x, x, x+l/10, x+9*l/10, x+l, x+l, x+9*l/10, x+l/10};
      int ypoints[] = {y, y-8*l/10, y-9*l/10, y-9*l/10, y-8*l/10, y, y+l/10, y+l/10};
      int npoints = 8;
      g.setColor(Color.red);  
      if (yellow==true){
         g.setColor(Color.yellow);  
      }
      g.fillPolygon(xpoints, ypoints, npoints);

      //numbers
      int radius = 5;
      g.setColor(Color.yellow);
      if (yellow==true){
         g.setColor(Color.red);  
      }

      if (roll==1){
        drawCircle(x+l/2, y-2*l/5, radius);
      }
      if (roll==2){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==3){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/2, y-2*l/5, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==4){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==5){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/2, y-2*l/5, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
      if (roll==6){
        drawCircle(x+l/10+2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-4*l/5+2*radius, radius);
        drawCircle(x+l/10+2*radius, y-2*l/5, radius);
        drawCircle(x+9*l/10-2*radius, y-2*l/5, radius);
        drawCircle(x+l/10+2*radius, y-2*radius, radius);
        drawCircle(x+9*l/10-2*radius, y-2*radius, radius);
      }
  }

  public void drawRoad(int x, int y, int currentPlayer){
      g.setColor(blue);
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //for building a road
      int xpoints[] = {x, x, x+2*a, x+2*a};
      int ypoints[] = {y, y-a/4, y-a/4, y};
      int npoints = 4;
      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawSetty(int x, int y, int currentPlayer){
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }
      //city
      int xpoints[] = {x, x, x+a/2, x+a, x+a};
      int ypoints[] = {y, y-a, y-3*a/2, y-a, y};
      int npoints = 5;

      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawCity(int x, int y, int currentPlayer){
      if(currentPlayer==1){
        g.setColor(blue);
      }
      if(currentPlayer==2){
        g.setColor(red);
      }
      if(currentPlayer==3){
        g.setColor(orange);
      }
      if(currentPlayer==4){
        g.setColor(white);
      }

      //city
      int xpoints[] = {x, x, x+a/2, x+a, x+a, x+2*a, x+2*a};
      int ypoints[] = {y, y-3*a/2, y-2*a, y-3*a/2, y-a, y-a, y};
      int npoints = 7;
      g.fillPolygon(xpoints, ypoints, npoints);

      if(currentPlayer==4){
        g.setColor(white);
        g.fillPolygon(xpoints, ypoints, npoints);
        g.setColor(Color.black);
        g.drawPolygon(xpoints, ypoints, npoints);
      }
  }

  public void drawRobber(int x, int y){
    g.setColor(robberGray);
    drawCircle(x+w, y-a, 20);
    g.setColor(newGray);
    drawCircle(x+w, y-a, 17);
    g.setColor(robberGray);
    drawCircle(x+w, y-a, 10);
  }

  public void drawDevelopement(int l, int x, int y){

          //Draw card outline
          g.setColor(Color.white);  
          drawCardOutline(3*a/2, x, y);
          //inside circles
          l=l+8;
          x=x+6*l/20-2;
          y=y-l/2+4;
          int radius=35;
          g.setColor(Color.lightGray);
          drawCircle(x, y, radius+1);
          g.setColor(brick);
          drawCircle(x, y, radius-2);
          g.setColor(darkBlue);
          g.fillArc(x+-32, y-21, radius+29, radius+19, 0, -180);
          g.setColor(darkYellow);
          drawCircle(x, y, radius-15);
          g.setColor(Color.lightGray);
          drawCircle(x, y, radius-25);
          g.setColor(stone);
          drawCircle(x, y, radius-27);
  }

  public void drawCardOutline(int l, int x, int y){
          //This b is an altered a
          int xpoints[] = {x, x-l/10, x-l/10, x, x+6*l/5, x+13*l/10, x+13*l/10,x+6*l/5};
          int ypoints[] = {y, y-l/10, y-19*l/10, y-2*l, y-2*l, y-19*l/10, y-l/10, y};
          int npoints = 8;
          g.fillPolygon(xpoints, ypoints, npoints);
  }

  public void drawCards(int x, int y){
      //Drawing cards under PLayers
      for(int j=0; j<5; j++){
        drawResourceCards(x+j*2*a, y, 5-j);
      }
  }

  public void drawResourceCards(int x, int y, int resource){
          //Setting Card Outline
          g.setColor(Color.white); 
          drawCardOutline(a, x, y);

          if (resource==1){
             g.setColor(stone);
          }
          else if (resource==2){
             g.setColor(wheat);
          }
          else if (resource==3){
             g.setColor(brick);
          }
          else if (resource==4){
             g.setColor(wood);
          }      
          else if (resource==5){
             g.setColor(sheep);
          }
          drawCardOutline(a-4, x+2, y-4);
  }
  
  public void drawPlayers(Graphics2D g2,int x, int y, int players){
      Font font = new Font("Gill Sans", Font.PLAIN, 20);
      g2.setFont(font);
      //Writes Player names
      g.setColor(blue);  
      g2.drawString("Player One", x, y);
      g.setColor(red);
      g2.drawString("Player Two", x, y+150);
      g.setColor(orange);
      g2.drawString("Player Three", x, y+300);
      //Adds fourth Player
      if(players==4){
        g.setColor(newGray);
        g2.drawString("Player Four", x, y+450);
      }  

      font = new Font("Gill Sans", Font.PLAIN, 15);
      g2.setFont(font);
      //draws cards
      g2.setColor(stone);
      for(int i=0; i<players;i++){
        g2.drawString("Sheep   ", x, y+25+i*150);
        g2.drawString("Wood    ", x, y+40+i*150); 
        g2.drawString("Brick   ", x, y+55+i*150);
        g2.drawString("Wheat   ", x, y+70+i*150);
        g2.drawString("Stone   ", x, y+85+i*150);
      }  
  }

  public void drawResources(Graphics2D g2, int currentPlayer, int[] resourceCount){
      Font font = new Font("Gill Sans", Font.PLAIN, 15);
      g2.setFont(font);
      //draws cards
      g2.setColor(stone);

      String stone = Integer.toString(resourceCount[1]);
      if(stone.equals("0")){
        stone=" ";
      }
      String wheat = Integer.toString(resourceCount[2]);
      if(wheat.equals("0")){
        wheat=" ";
      }
      String brick = Integer.toString(resourceCount[3]);
      if(brick.equals("0")){
        brick=" ";
      }
      String wood = Integer.toString(resourceCount[4]);
      if(wood.equals("0")){
        wood=" ";
      }
      String sheep = Integer.toString(resourceCount[5]);
      if(sheep.equals("0")){
        sheep=" ";
      }

      int x=950;
      int y=300;

      int i=currentPlayer-1;
      g2.drawString(sheep, x, y+25+i*150);
      g2.drawString(wood, x, y+40+i*150); 
      g2.drawString(brick, x, y+55+i*150);
      g2.drawString(wheat, x, y+70+i*150);
      g2.drawString(stone, x, y+85+i*150);

      repaint();
      
  }

  private void drawCircle(int x, int y, int radius) {
    g.fillOval(x-radius, y-radius, radius*2, radius*2);
  }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.ClassCastException

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-10 14:38:33.518
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.ClassCastException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:247)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.ClassCastException
Caused by: java.lang.ClassCastException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 14:38:33.518
!MESSAGE java.lang.ClassCastException
!STACK 0
java.lang.ClassCastException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 14:38:33.518
!MESSAGE java.lang.ClassCastException
!STACK 0
java.lang.ClassCastException

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-10 14:38:33.519
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.ClassCastException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:247)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:269)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1205)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:133)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.ClassCastException
Caused by: java.lang.ClassCastException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-03-10 14:38:33.519
!MESSAGE java.lang.ClassCastException
!STACK 0
java.lang.ClassCastException
!SESSION 2015-03-10 18:57:23.729 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-10 18:57:30.945
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-10 19:01:00.134 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-10 19:01:07.627
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-10 21:28:23.175 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-10 21:28:30.585
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-12 07:39:04.499 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-12 07:39:11.989
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-12 11:27:07.739 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-12 11:27:15.042
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-12 13:49:19.926 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-12 13:49:31.768
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-12 13:51:40.068 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-12 13:51:49.213
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-12 15:05:08.331 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-12 15:05:15.566
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-24 20:58:03.911 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-24 20:58:10.907
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences

!ENTRY org.eclipse.jdt.core 4 4 2015-03-24 21:07:14.859
!MESSAGE Background Indexer Crash Recovery
!STACK 0
java.lang.OutOfMemoryError: Java heap space
	at org.eclipse.jdt.internal.compiler.util.HashtableOfObject.<init>(HashtableOfObject.java:38)
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:634)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:459)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:451)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:541)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:192)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:774)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:816)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:546)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:388)
	at java.lang.Thread.run(Thread.java:695)
!SESSION 2015-03-24 21:08:09.903 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-24 21:08:16.449
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
!SESSION 2015-03-24 21:21:33.139 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_65
java.vendor=Apple Inc.
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/juliaedholm/.eclipse_keyring -showlocation

!ENTRY org.eclipse.core.net 1 0 2015-03-24 21:21:39.867
!MESSAGE System property http.nonProxyHosts has been set to local|*.local|169.254/16|*.169.254/16 by an external source. This value will be overwritten using the values from the preferences
